{"version":3,"file":"scripts-loader.min.js","names":["P","Promise","resolve","reject","fulfilled","value","step","generator","next","e","rejected","result","done","then","apply","thisArg","_arguments","data","trim","charAt","DOMParser","parseFromString","_a","JSON","parse","_b","renderer","item","sources","length","dependencies","promises","Array","concat","map","dependencyName","dependentScript","find","script","name","all","_","loadScriptFromSource","console","error","catch","loadScriptFromAjax","loadScriptFromFetch","Error","scriptE","document","createElement","type","src","shift","onload","onerror","head","appendChild","XMLHttpRequest","xhr","readyState","DONE","status","Function","responseText","send","resp","text","ex","err","array","isArray","every","x","ScriptObject","super","add","scriptObject","this","push","names","s","constructor","assign","detectFormatXmlOrJson","$ls","xml","json","loadScript","validateXmlAsScriptArray","fetch","validateJsonAsScriptArray","validateAsScriptArray","ajax","Object","url","mode","open","onreadystatechange","response","ScriptArray","numAttributes","keys","source","dependency","xmlDoc","namespace","getElementsByTagNameNS"],"sourceRoot":"./src/","sources":["./src/detectFormatXmlOrJson.ts","./src/loadScript.ts","./src/scriptArray.ts","./src/scriptObject.ts","./src/shortHand.ts","./src/validateAsScriptArray.ts","./src/validateJsonAsScriptArray.ts","./src/validateXmlAsScriptArray.ts"],"sourcesContent":["/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2023 Mubarrat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/**\r\n * An simple implementation that the data is xml or json.\r\n * @param data The data to be checked.\r\n * @returns If data is in xml, \"xml\". Or if data is in json, \"json\". Or an empty string will be returned.\r\n */\r\nfunction detectFormatXmlOrJson(data: string): \"xml\" | \"json\" | \"\" {\r\n\r\n  // Case the first char\r\n  switch (data.trim().charAt(0)) {\r\n\r\n    // If starts with `<`\r\n    case '<':\r\n\r\n      // Surround with try/catch\r\n      try {\r\n\r\n        // If xml, try parsing with DOM parser\r\n        new DOMParser().parseFromString(data, \"text/xml\");\r\n\r\n        // Return xml data type and parsing successful\r\n        return \"xml\";\r\n      }\r\n\r\n      // This is not clearly xml, since exception thrown\r\n      catch {\r\n\r\n        // Return empty string\r\n        return \"\";\r\n      }\r\n\r\n    // If starts with `{` or `[`\r\n    case '{':\r\n    case '[':\r\n\r\n      // Surround with try/catch\r\n      try {\r\n\r\n        // If json, try parsing\r\n        JSON.parse(data);\r\n\r\n        // Return json data type, parse successful\r\n        return \"json\";\r\n      }\r\n      \r\n      // This is not clearly json, since exception thrown\r\n      catch {\r\n\r\n        // Return empty string\r\n        return \"\";\r\n      }\r\n\r\n    // If anything else\r\n    default:\r\n\r\n      // Return empty string\r\n      return \"\";\r\n  }\r\n}\r\n","/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2023 Mubarrat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/**\r\n * An function that loads script.\r\n * @param data The script array where scripts will be loaded.\r\n * @param renderer The renderer type can either be \"document\" or \"ajax\" or \"fetch\"\r\n */\r\nfunction loadScript(data: ScriptArray, renderer: \"document\" | \"ajax\" | \"fetch\") {\r\n  \r\n  // Switch the cases and set promises\r\n  switch (renderer) {\r\n    \r\n    // If renderer mode is document\r\n    case \"document\":\r\n\r\n      // Iterate item of given Script Array\r\n      for (const item of data) {\r\n\r\n        // Check id sources length is zero\r\n        if (item.sources.length === 0) {\r\n\r\n          // Skip if no sources provided\r\n          continue;\r\n        }\r\n        \r\n        // It has Additonal dependencies.\r\n        if (item.dependencies.length > 0) {\r\n\r\n          // Flatten the array.\r\n          const promises = new Array<Promise<void>>().concat(...item.dependencies.map(dependencyName => {\r\n\r\n            // Find the script object with the given dependency name\r\n            const dependentScript = data.find(script => script.name === dependencyName);\r\n\r\n            // If dependentScript, return it's promises or tell promise to resolve it.\r\n            return dependentScript ? dependentScript.promises : Promise.resolve();\r\n          }));\r\n\r\n          // Merge the existing promises with the promises from dependencies\r\n          // Do the promise all to load this script\r\n          Promise.all(item.promises = item.promises.concat(...promises))\r\n\r\n            // Succeed or rejected\r\n            .then(_ => loadScriptFromSource([...item.sources]), console.error)\r\n\r\n            // Any error, let's console error\r\n            .catch(console.error);\r\n        }\r\n        \r\n        // It has no dependencies\r\n        else {\r\n\r\n          // Use triple dots so that original source doesn't get replaced.\r\n          item.promises = item.promises.concat(loadScriptFromSource([...item.sources]));\r\n        }\r\n      }\r\n      break;\r\n      \r\n    // If renderer mode is ajax\r\n    case \"ajax\":\r\n\r\n      // Iterate item of given Script Array\r\n      for (const item of data) {\r\n\r\n        // Check id sources length is zero\r\n        if (item.sources.length === 0) {\r\n\r\n          // Skip if no sources provided\r\n          continue;\r\n        }\r\n        \r\n        // It has Additonal dependencies.\r\n        if (item.dependencies.length > 0) {\r\n\r\n          // Flatten the array.\r\n          const promises = new Array<Promise<void>>().concat(...item.dependencies.map(dependencyName => {\r\n\r\n            // Find the script object with the given dependency name\r\n            const dependentScript = data.find(script => script.name === dependencyName);\r\n\r\n            // If dependentScript, return it's promises or tell promise to resolve it.\r\n            return dependentScript ? dependentScript.promises : Promise.resolve();\r\n          }));\r\n\r\n          // Merge the existing promises with the promises from dependencies\r\n          // Do the promise all to load this script\r\n          Promise.all(item.promises = item.promises.concat(...promises))\r\n\r\n            // Succeed or rejected\r\n            .then(_ => loadScriptFromAjax([...item.sources]), console.error)\r\n\r\n            // Any error, let's console error\r\n            .catch(console.error);\r\n        }\r\n        \r\n        // It has no dependencies\r\n        else {\r\n\r\n          // Use triple dots so that original source doesn't get replaced.\r\n          item.promises = item.promises.concat(loadScriptFromAjax([...item.sources]));\r\n        }\r\n      }\r\n      break;\r\n      \r\n      // If renderer mode is fetch\r\n      case \"fetch\":\r\n  \r\n        // Iterate item of given Script Array\r\n        for (const item of data) {\r\n  \r\n          // Check id sources length is zero\r\n          if (item.sources.length === 0) {\r\n  \r\n            // Skip if no sources provided\r\n            continue;\r\n          }\r\n          \r\n          // It has Additonal dependencies.\r\n          if (item.dependencies.length > 0) {\r\n  \r\n            // Flatten the array.\r\n            const promises = new Array<Promise<void>>().concat(...item.dependencies.map(dependencyName => {\r\n  \r\n              // Find the script object with the given dependency name\r\n              const dependentScript = data.find(script => script.name === dependencyName);\r\n  \r\n              // If dependentScript, return it's promises or tell promise to resolve it.\r\n              return dependentScript ? dependentScript.promises : Promise.resolve();\r\n            }));\r\n  \r\n            // Merge the existing promises with the promises from dependencies\r\n            // Do the promise all to load this script\r\n            Promise.all(item.promises = item.promises.concat(...promises))\r\n  \r\n              // Succeed or rejected\r\n              .then(_ => loadScriptFromFetch([...item.sources]), console.error)\r\n  \r\n              // Any error, let's console error\r\n              .catch(console.error);\r\n          }\r\n          \r\n          // It has no dependencies\r\n          else {\r\n  \r\n            // Use triple dots so that original source doesn't get replaced.\r\n            item.promises = item.promises.concat(loadScriptFromFetch([...item.sources]));\r\n          }\r\n        }\r\n        break;\r\n\r\n    // The renderer mode is unknown\r\n    default:\r\n\r\n      // Throw an error\r\n      throw new Error('`renderer` is either be \"document\" or \"ajax\" or \"fetch\"');\r\n  }\r\n\r\n  // An inner method - for renderer mode is document\r\n  function loadScriptFromSource(sources: string[]): Promise<void> {\r\n\r\n    // Return new promise\r\n    return new Promise((resolve, reject) => {\r\n\r\n      // Reject if all sources failed\r\n      if (sources.length === 0) {\r\n\r\n        reject('All sources failed.');\r\n        return;\r\n      }\r\n\r\n      // Create a new script element\r\n      const scriptE = document.createElement(\"script\");\r\n\r\n      // Set the type\r\n      scriptE.type = 'text/javascript';\r\n\r\n      // Set the source, shifting has no chance of unknown\r\n      scriptE.src = sources.shift() as string;\r\n\r\n      // Since loaded, resolve it\r\n      scriptE.onload = () => resolve();\r\n\r\n      // Since error, try loading fallback sources\r\n      scriptE.onerror = () => loadScriptFromSource(sources).then(resolve).catch(reject);\r\n\r\n      // Append to the child of head\r\n      document.head.appendChild(scriptE);\r\n    });\r\n  }\r\n\r\n  // Second inner method - for renderer mode is ajax\r\n  function loadScriptFromAjax(sources: string[]): Promise<void> {\r\n\r\n    // Return new promise\r\n    return new Promise((resolve, reject) => {\r\n\r\n      // Reject if all sources failed\r\n      if (sources.length === 0) {\r\n\r\n        reject('All sources failed.');\r\n        return;\r\n      }\r\n\r\n      // Create a new xml http request\r\n      const xhr = new XMLHttpRequest();\r\n\r\n      // Open the request\r\n      xhr.open('GET', sources.shift() as string);\r\n\r\n      // Done\r\n      xhr.onreadystatechange = function () {\r\n\r\n        // If request is done\r\n        if (xhr.readyState === XMLHttpRequest.DONE) {\r\n\r\n          // If xhr status is 200\r\n          if (xhr.status === 200) {\r\n\r\n            // Don't surrounding because our methods are correct and error happens in their js file\r\n\r\n            // Create a function and load the js\r\n            new Function(xhr.responseText)();\r\n\r\n            // Resolved\r\n            resolve();\r\n          }\r\n          \r\n          // Not ok - 200\r\n          else {\r\n\r\n            // Try loading fallbacks\r\n            loadScriptFromSource(sources).then(resolve).catch(reject)\r\n          }\r\n        }\r\n      };\r\n\r\n      // Send the request\r\n      xhr.send();\r\n    });\r\n  }\r\n\r\n  // Third inner method - for renderer mode is fetch\r\n  function loadScriptFromFetch(sources: string[]): Promise<void> {\r\n\r\n    // Return new promise\r\n    return new Promise((resolve, reject) => {\r\n\r\n      // Reject if all sources failed\r\n      if (sources.length === 0) {\r\n\r\n        reject('All sources failed.');\r\n        return;\r\n      }\r\n\r\n      fetch(sources.shift() as string)\r\n\r\n        // Succeeded\r\n        .then(resp => {\r\n\r\n          // Open the request and get by starting fetching\r\n          resp.text().then(data => {\r\n\r\n            // Surround with try/catch \r\n            try {\r\n\r\n              // Create a function and load the JavaScript\r\n              new Function(data)();\r\n            }\r\n\r\n            // Our functions are ok. The problem is in the source.\r\n            catch (ex) {\r\n\r\n              // Let's log the error\r\n              console.error(ex);\r\n            }\r\n\r\n            // Resolved\r\n            resolve();\r\n          });\r\n        })\r\n        \r\n        // Error occurred\r\n        .catch(err => {\r\n\r\n          // Try loading fallbacks\r\n          loadScriptFromSource(sources).then(resolve).catch(reject)\r\n        });\r\n    });\r\n  }\r\n}\r\n","/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2023 Mubarrat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/**\r\n * The script array class\r\n */\r\nclass ScriptArray extends Array<ScriptObject> {\r\n\r\n  /**\r\n   * The constructor of this script array.\r\n   * @param array The array of this class.\r\n   */\r\n  constructor(...array: ScriptObject[]) {\r\n\r\n    // Check if `array` isn't an array\r\n    if (!Array.isArray(array)) {\r\n\r\n      // Throw an error because it's not\r\n      throw new Error(\"`array` isn't array\");\r\n    }\r\n\r\n    // Check if items of `array` isn't ScriptObject\r\n    if (!array.every(x => x instanceof ScriptObject)) {\r\n\r\n      // Throw an error because it's not\r\n      throw new Error(\"Every item of `array` isn't an instance of ScriptObject\");\r\n    }\r\n    \r\n    // Assign array to this\r\n    super(...array);\r\n  }\r\n\r\n  /**\r\n   * Adds an script object.\r\n   * @param scriptObject The script object to be added.\r\n   * @returns Return the number of adding.\r\n   */\r\n  add(scriptObject: ScriptObject): number {\r\n\r\n    // Return the number\r\n    return this.push(scriptObject);\r\n  }\r\n\r\n  /**\r\n   * Get all names.\r\n   */\r\n  get names(): string[] {\r\n\r\n    // Return by mapping to the name\r\n    return this.map(s => s.name);\r\n  }\r\n}\r\n","/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2023 Mubarrat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/**\r\n * A class for script object.\r\n */\r\nclass ScriptObject {\r\n\r\n  /**\r\n   * A name for using in another dependency\r\n   */\r\n  name: string = \"\";\r\n\r\n  /**\r\n   * Sources for this object. Not-first sources are fallback.\r\n   */\r\n  sources: string[] = [];\r\n\r\n  /**\r\n   * Dependencies for this javaScript\r\n   */\r\n  dependencies: string[] = [];\r\n\r\n  /**\r\n   * An promise list. Merge promises here\r\n   */\r\n  promises: Promise<void>[] = [];\r\n}\r\n","/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2023 Mubarrat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/**\r\n * Define an shortname with objects.\r\n */\r\nconst $ls = Object.assign((data: string | {}[]) => {\r\n\r\n  // Let's check data is a string or an object array\r\n  if (typeof data !== \"string\" && !Array.isArray(data)) {\r\n\r\n    // Throw an error\r\n    throw new Error(\"`data` should be either string or an object array.\");\r\n  }\r\n\r\n  // If data is an string\r\n  if (typeof data === \"string\") {\r\n\r\n    // Switch case\r\n    switch (detectFormatXmlOrJson(data)) {\r\n\r\n      // If an xml type\r\n      case \"xml\":\r\n        \r\n        // Call Xml Helper Method\r\n        $ls.xml(data);\r\n        break;\r\n\r\n      // If an json type\r\n      case \"json\":\r\n        \r\n        // Call Json Helper Method\r\n        $ls.json(data);\r\n        break;\r\n\r\n      // If anything else\r\n      default:\r\n\r\n        // Throw an error\r\n        throw new Error(\"Unknown type\");\r\n    }\r\n  }\r\n\r\n  // Data is an array\r\n  else {\r\n\r\n    // Call the helper method\r\n    $ls.document(data);\r\n  }\r\n}, {\r\n\r\n  /**\r\n   * An xml helper function.\r\n   */\r\n  xml: Object.assign((data: string) => {\r\n\r\n    // If data isn't string\r\n    if (typeof data !== \"string\") {\r\n\r\n      // Throw an error\r\n      throw new Error(\"data should be string\");\r\n    }\r\n\r\n    // Load script\r\n    $ls.xml.document(data);\r\n  }, {\r\n\r\n    /**\r\n     * This is document injection rendering mode.\r\n     * @param data The xml data.\r\n     */\r\n    document(data: string) {\r\n\r\n      // If data isn't string\r\n      if (typeof data !== \"string\") {\r\n\r\n        // Throw an error\r\n        throw new Error(\"data should be string\");\r\n      }\r\n\r\n      // Load script\r\n      loadScript(validateXmlAsScriptArray(data), \"document\");\r\n    },\r\n\r\n    /**\r\n     * This is ajax loading rendering mode.\r\n     * @param data The xml data.\r\n     */\r\n    ajax(data: string) {\r\n\r\n      // If data isn't string\r\n      if (typeof data !== \"string\") {\r\n\r\n        // Throw an error\r\n        throw new Error(\"data should be string\");\r\n      }\r\n\r\n      // Load script\r\n      loadScript(validateXmlAsScriptArray(data), \"ajax\");\r\n    },\r\n\r\n    /**\r\n     * This is fetching rendering mode.\r\n     * @param data The xml data.\r\n     */\r\n    fetch(data: string) {\r\n\r\n      // If data isn't string\r\n      if (typeof data !== \"string\") {\r\n\r\n        // Throw an error\r\n        throw new Error(\"data should be string\");\r\n      }\r\n\r\n      // Load script\r\n      loadScript(validateXmlAsScriptArray(data), \"fetch\");\r\n    }\r\n  }),\r\n\r\n  /**\r\n   * An json helper function\r\n   */\r\n  json: Object.assign((data: string) => {\r\n\r\n    // If data isn't string\r\n    if (typeof data !== \"string\") {\r\n\r\n      // Throw an error\r\n      throw new Error(\"data should be string\");\r\n    }\r\n\r\n    // Load script\r\n    $ls.json.document(data);\r\n  }, {\r\n\r\n    /**\r\n     * This is document injection rendering mode.\r\n     * @param data The json data.\r\n     */\r\n    document(data: string) {\r\n\r\n      // If data isn't string\r\n      if (typeof data !== \"string\") {\r\n\r\n        // Throw an error\r\n        throw new Error(\"data should be string\");\r\n      }\r\n\r\n      // Load script\r\n      loadScript(validateJsonAsScriptArray(data), \"document\");\r\n    },\r\n\r\n    /**\r\n     * This is ajax loading rendering mode.\r\n     * @param data The json data.\r\n     */\r\n    ajax(data: string) {\r\n\r\n      // If data isn't string\r\n      if (typeof data !== \"string\") {\r\n\r\n        // Throw an error\r\n        throw new Error(\"data should be string\");\r\n      }\r\n\r\n      // Load script\r\n      loadScript(validateJsonAsScriptArray(data), \"ajax\");\r\n    },\r\n\r\n    /**\r\n     * This is fetching rendering mode.\r\n     * @param data The json data.\r\n     */\r\n    fetch(data: string) {\r\n\r\n      // If data isn't string\r\n      if (typeof data !== \"string\") {\r\n\r\n        // Throw an error\r\n        throw new Error(\"data should be string\");\r\n      }\r\n\r\n      // Load script\r\n      loadScript(validateJsonAsScriptArray(data), \"fetch\");\r\n    }\r\n  }),\r\n\r\n  /**\r\n   * This is document injection rendering mode.\r\n   * @param data The script array.\r\n   */\r\n  document(data: string | {}[]) {\r\n\r\n    // Let's check data is a string or an object array\r\n    if (typeof data !== \"string\" && !Array.isArray(data)) {\r\n\r\n      // Throw an error\r\n      throw new Error(\"`data` should be either string or an object array.\");\r\n    }\r\n\r\n    // If data is an string\r\n    if (typeof data === \"string\") {\r\n\r\n      // Switch case\r\n      switch (detectFormatXmlOrJson(data)) {\r\n\r\n        // If an xml type\r\n        case \"xml\":\r\n          \r\n          // Call Xml Helper Method\r\n          $ls.xml.document(data);\r\n          break;\r\n\r\n        // If an json type\r\n        case \"json\":\r\n          \r\n          // Call Json Helper Method\r\n          $ls.json.document(data);\r\n          break;\r\n\r\n        // If anything else\r\n        default:\r\n\r\n          // Throw an error\r\n          throw new Error(\"Unknown type\");\r\n      }\r\n    }\r\n\r\n    // Data is an array\r\n    else {\r\n\r\n      // Load script\r\n      loadScript(validateAsScriptArray(data), \"document\");\r\n    }\r\n  },\r\n\r\n  /**\r\n   * This is ajax loading rendering mode.\r\n   * @param data The script array.\r\n   */\r\n  ajax(data: string | {}[]) {\r\n\r\n    // Let's check data is a string or an object array\r\n    if (typeof data !== \"string\" && !Array.isArray(data)) {\r\n\r\n      // Throw an error\r\n      throw new Error(\"`data` should be either string or an object array.\");\r\n    }\r\n\r\n    // If data is an string\r\n    if (typeof data === \"string\") {\r\n\r\n      // Switch case\r\n      switch (detectFormatXmlOrJson(data)) {\r\n\r\n        // If an xml type\r\n        case \"xml\":\r\n          \r\n          // Call Xml Helper Method\r\n          $ls.xml.ajax(data);\r\n          break;\r\n\r\n        // If an json type\r\n        case \"json\":\r\n          \r\n          // Call Json Helper Method\r\n          $ls.json.ajax(data);\r\n          break;\r\n\r\n        // If anything else\r\n        default:\r\n\r\n          // Throw an error\r\n          throw new Error(\"Unknown type\");\r\n      }\r\n    }\r\n\r\n    // Data is an array\r\n    else {\r\n\r\n      // Load script\r\n      loadScript(validateAsScriptArray(data), \"ajax\");\r\n    }\r\n  },\r\n\r\n  /**\r\n   * This is fetching rendering mode.\r\n   * @param data The script array.\r\n   */\r\n  fetch(data: string | {}[]) {\r\n\r\n    // Let's check data is a string or an object array\r\n    if (typeof data !== \"string\" && !Array.isArray(data)) {\r\n\r\n      // Throw an error\r\n      throw new Error(\"`data` should be either string or an object array.\");\r\n    }\r\n\r\n    // If data is an string\r\n    if (typeof data === \"string\") {\r\n\r\n      // Switch case\r\n      switch (detectFormatXmlOrJson(data)) {\r\n\r\n        // If an xml type\r\n        case \"xml\":\r\n          \r\n          // Call Xml Helper Method\r\n          $ls.xml.fetch(data);\r\n          break;\r\n\r\n        // If an json type\r\n        case \"json\":\r\n          \r\n          // Call Json Helper Method\r\n          $ls.json.fetch(data);\r\n          break;\r\n\r\n        // If anything else\r\n        default:\r\n\r\n          // Throw an error\r\n          throw new Error(\"Unknown type\");\r\n      }\r\n    }\r\n\r\n    // Data is an array\r\n    else {\r\n\r\n      // Load script\r\n      loadScript(validateAsScriptArray(data), \"fetch\");\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Load from url\r\n   * @param url The url where is data\r\n   * @param mode The loading mode\r\n   */\r\n  url: Object.assign((url: string, mode: \"ajax\" | \"fetch\" = \"fetch\") => {\r\n\r\n    // If url isn't striing\r\n    if (typeof url !== \"string\") {\r\n\r\n      // Let's throw an error\r\n      throw new Error(\"url must be string\");\r\n    }\r\n\r\n    // If mode is neither \"ajax\" nor \"fetch\"\r\n    if (mode != \"ajax\" && mode != \"fetch\") {\r\n\r\n      // Let's throw an error\r\n      throw new Error(`mode must be either \"ajax\" or \"fetch\"`);\r\n    }\r\n\r\n    // Let's call helpers\r\n    $ls.url.document(url, mode);\r\n  }, {\r\n\r\n    /**\r\n     * This is document injection rendering mode from url.\r\n     * @param url The url where is data\r\n     * @param mode The loading mode\r\n     */\r\n    async document(url: string, mode: \"ajax\" | \"fetch\" = \"fetch\") {\r\n\r\n      // Switch between cases\r\n      switch (mode) {\r\n\r\n        // If mode is ajax\r\n        case \"ajax\":\r\n  \r\n          // Create a new request\r\n          const xhr = new XMLHttpRequest;\r\n  \r\n          // Open the request\r\n          xhr.open(\"GET\", url);\r\n  \r\n          // Handle the request\r\n          xhr.onreadystatechange = () => xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200 && $ls.document(xhr.responseText);\r\n  \r\n          // Send the request\r\n          xhr.send();\r\n          break;\r\n  \r\n        // If mode is fetch\r\n        case \"fetch\":\r\n            \r\n          // Start fetching\r\n          fetch(url)\r\n\r\n            // Then read the text\r\n            .then(response => {\r\n\r\n              // Get the response by creating a fetch request\r\n              return response.text();\r\n            })\r\n\r\n            // Then load the data\r\n            .then(data => {\r\n\r\n              // Execute\r\n              return $ls.document(data);\r\n            })\r\n          break;\r\n  \r\n        // If mode is anything else\r\n        default:\r\n  \r\n          // Let's throw an error\r\n          throw new Error(`Loading mode can either be \"ajax\" or \"fetch\"`)\r\n      }\r\n    },\r\n\r\n    /**\r\n     * This is document injection rendering mode from url.\r\n     * @param url The url where is data\r\n     * @param mode The loading mode\r\n     */\r\n    async ajax(url: string, mode: \"ajax\" | \"fetch\" = \"fetch\") {\r\n\r\n      // Switch between cases\r\n      switch (mode) {\r\n\r\n        // If mode is ajax\r\n        case \"ajax\":\r\n  \r\n          // Create a new request\r\n          const xhr = new XMLHttpRequest;\r\n  \r\n          // Open the request\r\n          xhr.open(\"GET\", url);\r\n  \r\n          // Handle the request\r\n          xhr.onreadystatechange = () => xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200 && $ls.ajax(xhr.responseText);\r\n  \r\n          // Send the request\r\n          xhr.send();\r\n          break;\r\n  \r\n        // If mode is fetch\r\n        case \"fetch\":\r\n            \r\n          // Start fetching\r\n          fetch(url)\r\n\r\n            // Then read the text\r\n            .then(response => {\r\n\r\n              // Get the response by creating a fetch request\r\n              return response.text();\r\n            })\r\n\r\n            // Then load the data\r\n            .then(data => {\r\n\r\n              // Execute\r\n              return $ls.ajax(data);\r\n            })\r\n          break;\r\n  \r\n        // If mode is anything else\r\n        default:\r\n  \r\n          // Let's throw an error\r\n          throw new Error(`Loading mode can either be \"ajax\" or \"fetch\"`)\r\n      }\r\n    },\r\n\r\n    /**\r\n     * This is document injection rendering mode from url.\r\n     * @param url The url where is data\r\n     * @param mode The loading mode\r\n     */\r\n    fetch(url: string, mode: \"ajax\" | \"fetch\" = \"fetch\") {\r\n\r\n      // Switch between cases\r\n      switch (mode) {\r\n\r\n        // If mode is ajax\r\n        case \"ajax\":\r\n  \r\n          // Create a new request\r\n          const xhr = new XMLHttpRequest;\r\n  \r\n          // Open the request\r\n          xhr.open(\"GET\", url);\r\n  \r\n          // Handle the request\r\n          xhr.onreadystatechange = () => xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200 && $ls.fetch(xhr.responseText);\r\n  \r\n          // Send the request\r\n          xhr.send();\r\n          break;\r\n  \r\n        // If mode is fetch\r\n        case \"fetch\":\r\n            \r\n          // Start fetching\r\n          fetch(url)\r\n\r\n            // Then read the text\r\n            .then(response => {\r\n\r\n              // Get the response by creating a fetch request\r\n              return response.text();\r\n            })\r\n\r\n            // Then load the data\r\n            .then(data => {\r\n\r\n              // Execute\r\n              return $ls.fetch(data);\r\n            })\r\n          break;\r\n  \r\n        // If mode is anything else\r\n        default:\r\n  \r\n          // Let's throw an error\r\n          throw new Error(`Loading mode can either be \"ajax\" or \"fetch\"`)\r\n      }\r\n    }\r\n  })\r\n});\r\n\r\n/*\r\nThe following code section defines a utility named $ls, facilitating the\r\nhandling of both strings and arrays of objects. This utility employs a\r\nstructure that accommodates multiple data formats, such as XML and JSON, and\r\ntheir respective rendering modes: document injection, AJAX loading, and\r\nfetching.\r\n\r\nThe initial function checks whether the input is a string or an array of\r\nobjects. If it's a string, it's further processed based on its format: XML or\r\nJSON. Subsequently, corresponding methods (xml or json) are invoked based on\r\nthe detected format. If the input is an array of objects, it calls the\r\n'document' method.\r\n\r\nThe 'xml' and 'json' methods within this utility serve as helpers. They contain\r\nthree rendering modes: document injection, AJAX loading, and fetching. Each\r\nrendering mode checks for the data type, performs necessary validations, and\r\nthen proceeds to load the script accordingly.\r\n\r\nAdditionally, the utility provides three methods - document, ajax, and fetch -\r\nto process script arrays. These methods check the input type, detect the format\r\n(XML or JSON), and handle the loading of the script accordingly.\r\n\r\nThere's also a 'url' method that accepts a URL and a loading mode ('ajax' or\r\n'fetch'). This method, in turn, employs the corresponding loading method to\r\nfetch data from the URL and subsequently call the relevant processing method\r\n('document', 'ajax', or 'fetch') based on the obtained data type and mode.\r\n\r\nDespite the current implementation appearing extensive, it has been consciously\r\ndesigned to provide comprehensive support for multiple data formats and various\r\nloading modes. The verbosity of the code is intended to ensure readability,\r\nmaintainability, and comprehensive handling of different data types and loading\r\nscenarios.\r\n\r\nWhat if this short hand didn't ever be made?\r\n*/\r\n","/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2023 Mubarrat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\nfunction validateAsScriptArray(data: {}[]): ScriptArray {\r\n\r\n  // Check if the root element is an array\r\n  if (!Array.isArray(data)) {\r\n\r\n    // Throw an error because it's not\r\n    throw new Error('Root element should be an array');\r\n  }\r\n\r\n  // Check each item in the array\r\n  return new ScriptArray(...data.map(item => {\r\n\r\n    // Check if each item is an object\r\n    if (typeof item !== 'object' || Array.isArray(item)) {\r\n\r\n      // Throw an error because it's not\r\n      throw new Error('Items should be objects');\r\n    }\r\n\r\n    // Number of attributes\r\n    const numAttributes = Object.keys(item).length;\r\n\r\n    // Check if number of attributes is from 1 to 3.\r\n    if (numAttributes < 1 || numAttributes > 3) {\r\n\r\n      // Throw an error because it's not\r\n      throw new Error('Items should have from 1 to 3 attributes');\r\n    }\r\n\r\n    // Define and out\r\n    const { name, source, sources, dependency, dependencies } = item as any;\r\n\r\n    // Check for required attributes\r\n    if (!source && !sources) {\r\n\r\n      // Throw an error\r\n      throw new Error('Attributes source(s) are required');\r\n    }\r\n\r\n    // Check if `source` and `sources` both are defined\r\n    if (source && sources) {\r\n\r\n      // Throw an error\r\n      throw new Error('source and sources both are defined');\r\n    }\r\n\r\n    // Return script object with assigned properties\r\n    return Object.assign(new ScriptObject, {\r\n\r\n      // Return name\r\n      name: name || \"\",\r\n\r\n      // Return sources\r\n      sources: sources || (source ? [source] : []),\r\n\r\n      // Return additional dependencies\r\n      dependencies: dependencies || (dependency ? [dependency] : [])\r\n    });\r\n  }));\r\n}\r\n","/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2023 Mubarrat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/**\r\n * It validates json as script array.\r\n * @param data The data to be parsed.\r\n * @returns Returns the parsed script array.\r\n */\r\nfunction validateJsonAsScriptArray(data: string): ScriptArray {\r\n\r\n  // Check if data is an string\r\n  if (typeof data !== \"string\") {\r\n\r\n    // Throw an error because it's not\r\n    throw new Error(\"`data` isn't string\");\r\n  }\r\n\r\n  // Convert string to json and use another validate method to validate\r\n  return validateAsScriptArray(JSON.parse(data));\r\n}\r\n","/*\r\n * MIT License\r\n *\r\n * Copyright (c) 2023 Mubarrat\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/**\r\n * It validates xml string as script array.\r\n * @param data The data to be parsed.\r\n * @returns Returns an script array.\r\n */\r\nfunction validateXmlAsScriptArray(data: string): ScriptArray {\r\n  \r\n  // Initialize a new DOM Parser\r\n  const parser = new DOMParser();\r\n\r\n  // Parse xml\r\n  const xmlDoc = parser.parseFromString(data, \"text/xml\");\r\n\r\n  // Namespace\r\n  const namespace = \"http://schemas.mubarrat.com/scripts-loader/\";\r\n\r\n  // Mapping and return to main validator to validate\r\n  return validateAsScriptArray([...xmlDoc.getElementsByTagNameNS(namespace, \"script\")].map(x => {\r\n\r\n    // Returns\r\n    return {\r\n\r\n      // Define name\r\n      name: x.getAttribute(\"name\"),\r\n\r\n      // Define sources\r\n      sources: [...x.getElementsByTagNameNS(namespace, \"source\")].map(x => x.textContent),\r\n\r\n      // Define dependencies\r\n      dependencies: [...x.getElementsByTagNameNS(namespace, \"dependency\")].map(x => x.textContent)\r\n    }\r\n  }));\r\n}\r\n"],"mappings":"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"}